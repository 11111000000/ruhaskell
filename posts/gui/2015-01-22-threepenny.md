---
author:      Алексей Пирогов
title:       Знакомство с Threepenny-GUI
tags:        GUI,FRP
description: Демонстрация создания простого GUI на основе Threepenny-GUI и Reactive Banana
---

## Здравствуй, Threepenny-GUI!

## Что же это?

Реализация графического интерфейса для приложений, это к сожалению пока ещё непростая задача (по крайней мере, для разработчиков на Haskell). Ещё больше усложняет задачу необходимость сделать приложение кроссплатформенным. Создатель [Threepenny-GUI](https://www.haskell.org/haskellwiki/Threepenny-gui) предлагает одно из решений данной проблемы - использование в качестве средства отображения интерфейса браузер. Такое решение даёт очевидные преимущества: используя браузер мы получаем отличную кросплатформенность, богатые возможности для оформления интерфейса. А кроме того Threepenny-GUI даёт нам возможность использовать при разработке ещё и FRP - Function Reactive Programming - очень мощный подход для разработки ПО, особенно - интерактивного. FRP в данном случае основывается на библиотеке [Reactive Banana](https://www.haskell.org/haskellwiki/Reactive-banana).

Замечу, что не стоит делать поспешных выводов и решать для себя, что разработка приложений, рассчитанных на отображение в браузере подразумевает под собой создание странички на HTML+JS с прикручиванием оной к простенькому серверу. К счастью, в данном случае это не так!

Данная статья, надеюсь, даст представление о возможность быстрой разработки GUI на Haskell, достаточное для того, чтобы иметь данный подход ввиду, буде такая задача возникнет.

Примером нам будет служить приложение, имитирующее настольный калькулятор с базовым набором операций. Его мы и разработаем. Итак, поехали!

![Banana](https://www.haskell.org/wikiupload/7/7c/Reactive-Banana-banana.png)

## Окно

> А мы увидели Солнце, открыли окна.
> А иначе зачем это все? ((с) "Пикник")

Каждое (ну, почти каждое) графическое приложение начинается с *окна*. Threepenny создаёт окно сама (помним, что это страница в браузере), от нас же ожидается его настройка и наполнение. Поручим это функции ``setup``, которая будет вызываться из ``main``:

```haskell
import           Control.Monad               (void)
import qualified Graphics.UI.Threepenny      as UI
import           Graphics.UI.Threepenny      (set, title, (#), UI, Window)
import           Graphics.UI.Threepenny.Core (startGUI, defaultConfig)

-- ...

setup :: Window -> UI ()
setup win = void $ do
  return win # set title "ReaCalc"

main :: IO ()
main = startGUI defaultConfig setup
```

Из кода видно, что работа с окном происходит в специальной монаде ``UI``. Само окно (как и все остальные UI-элементы) - "чистое", а операции над ними - "не очень", поэтому типичное взаимодействие с элементом выглядит так: ``return elem # set ... ...``.

В общем то, всё! Приложение уже можно запускать! У меня это выглядит так:

```shell
$ cabal run
Listening on http://127.0.0.1:8023/
[22/Jan/2015:20:23:04 +0300] Server.httpServe: START, binding to [http://127.0.0.1:8023/]
```

Открыв в браузере url ``http://127.0.0.1:8023/``, мы увидим страницу с указанным нами _title_. Да, страница пока пуста, но приложение уже работает!

Настало время наполнить окно содержимым. Создадим "индикатор" - элемент, отображающий результаты вычислений. Под индикатором будет располагаться блок клавиш. Дополним ``setup``:

```haskell
import           Graphics.UI.Threepenny      (set, attr, text, value, (#+))

-- ...

setup win = -- ...
  --- ...
  out <- UI.input # set (attr "readonly") "true"
                  # set (attr "style") "text-align: right; min-width: 240px"
                  # set value "0"

  buttons <- mapM (mapM mkButton) buttonLabels

  UI.getBody win #+ [return out]
                 #+ map UI.row (map (map return) buttons)

  where
    mkButton s = UI.input # set text s
                          # set value s
                          # set (attr "type") "button"
                          # set (attr "style") "min-width: 50px"

buttonLabels :: [[String]]
buttonLabels = map words $ lines "7 8 9 CE C\n4 5 6 + -\n1 2 3 * /\n . 0 ="
```

Элементы управления настраиваются так же, как это делалось бы в HTML - мы добавляем стили, указываем атрибуты, вот это всё. Но всё оперирование компонентами производится на Haskell, ну не красота ли!? На самом деле, красоты в текущем интерфейсе мало (на вид он, что называется, "инженерный"), ну да ладно, эта статья не о дизайне, всё таки!

Теперь интерфейс в наличии, настало время его "оживить"!

## Интерактив

> Нажми на кнопку, получишь результат! (тоже (с) чей-то..)

В Reactive Banana интерактивность описывется в терминах ``Event`` и ``Behaviour a``.

``Event a`` представляет собой, не одиночное событие, как это бывает в классических event-driven системах, а поток событий, выдаваемых потоком по мере того, как оные происходят. Каждое событие в потоке сопровождается временной отметкой и содержит некие данные (типа ``a``), характеризующие событие. Два потока событий одного типа можно объединить в один с помощью комбинатора ``UI.unionWith :: (a -> a -> a) -> Event a -> Event a -> Event a``. Этот комбинатор помимо, собственно, объединения занимается обработкой ситуации, когда два события из разных потоков имеют одинаковую временную отметку - в этом случае вызывается функция, передаваемая в комбинатор первым параметром.

``Behaviour a``, в свою очередь, изображает некую "ячейку", в которой хранятся данные типа ``a``. Данные в коробке всегда имеют некое мгновенное значение, меняющееся с течением времени под действием событий.

Наша программа изображает некое устройство (калькулятор), имеющее начальное состояние, возникающее единожды при "включении". В процессе работы это состояние меняется под действием команд - нажатий кнопок. Индикатор же калькулятора занимается отображением значения, характеризующего это сотояние. Состояние существует в течении всего времени работы кальклятора. Тут нам пригодится функция ``accumB :: 
